Param(
    [string]$Path,
    [bool]$Embedpsd1 = $false,
    [string]$Output = "compiledproject.ps1",
    [bool]$Exe = $false,
    [bool]$ExeConsole = $false,
    [bool]$Err = $true,
    [string]$SSN = ""
)
# Helper: Sanitize file path to valid function name
function Convert-PathToFunctionName {
    param(
        [string]$FullPath,
        [string]$BasePath
    )
    # Compute relative path and remove extension
    $relative = $FullPath.Substring($BasePath.Length).TrimStart('\','/')
    $name = [IO.Path]::ChangeExtension($relative, $null)
    # Replace invalid chars with hyphens, lowercase, then trim trailing hyphens
    $clean = ($name -replace '[\\/:\.\s]', '-').ToLower().TrimEnd('-')
    return "fn-$clean"
}

# Scan and order project files
function Get-ProjectFiles {
    param(
        [string]$BasePath
    )
    $fileTypes = @('*.psd1','*.psm1','*.ps1','*.bat','*.cmd')
    $files = foreach ($pattern in $fileTypes) {
        Get-ChildItem -Path $BasePath -Recurse -Filter $pattern -File | Sort-Object FullName
    }
    return $files
}

Write-Host "[INFO] Scanning path: $Path"
$allFiles = Get-ProjectFiles -BasePath $Path
if (-not $allFiles) {
    throw "No files found in $Path"
}

# Build mapping: full path to function name, and relative paths for call rewrites
$map = @{}
$relativeMap = @{}
foreach ($file in $allFiles) {
    $fn = Convert-PathToFunctionName -FullPath $file.FullName -BasePath $Path
    $map[$file.FullName] = $fn
    # Prepare relative variations for replacement
    $relPath = $file.FullName.Substring($Path.Length).TrimStart('\','/')
    $key1 = ".\$relPath"
    $key2 = $relPath
    $relativeMap[$key1] = $fn
    $relativeMap[$key2] = $fn
}

# Start bundling
$out = @()
$out += "# Auto-generated by PowerCompile"
$out += "# Bundle of project at $Path"
$out += "# You still have to call the first function. e.g.: fn-{STARTING_SCRIPT_NAME}`n"

foreach ($file in $allFiles) {
    $fnName = $map[$file.FullName]
    $ext = $file.Extension.ToLower()
    $content = Get-Content -Raw -LiteralPath $file.FullName

    $out += "function $fnName {"
    if ($Embedpsd1.IsPresent -and $ext -eq '.psd1') {
        # Embed PSD1 as Base64
        $bytes = [IO.File]::ReadAllBytes($file.FullName)
        $b64 = [Convert]::ToBase64String($bytes)
        $out += "    # Embedded base64 of $($file.Name)"
        $out += "    \$b64 = '$b64'"
        $out += "    [IO.File]::WriteAllBytes('$($file.Name)', [Convert]::FromBase64String(\$b64))"
    }
    elseif ($ext -eq '.psm1' -or $ext -eq '.ps1' -or $ext -eq '.bat' -or $ext -eq '.cmd') {
        # Rewrite internal calls and indent lines
        foreach ($line in $content -split "`r?`n") {
            $modified = $line
            foreach ($key in $relativeMap.Keys) {
                $modified = $modified -replace [regex]::Escape($key), $relativeMap[$key]
            }
            $out += "    $modified"
        }
    }
    $out += "}"  # Closing function
    $out += ""  # Blank line
}

# Append entry point invocation if specified
if ($EntryPointFunction) {
    $out += "# Invocation";
    $out += "$EntryPointFunction";
}

Write-Host "[INFO] Writing bundled script to $Output"
$out | Set-Content -LiteralPath $Output -Encoding UTF8
Write-Host "[SUCCESS] Bundle complete. Output: $Output" -ForegroundColor Green

if ($Err -eq "True") {
    Write-Host "[INFO] Scanning for Errors"
    .\bin\check.ps1 -Path $Output
    Write-Host "[INFO] Preformed Error Handling on $Output"
}

$SSN = $SSN.Replace(".\\", "")
$SSN = $SSN.Replace("\\", "")
$SSN = $SSN.Replace(".\", "")
$SSN = $SSN.Replace(".//", "")
$SSN = $SSN.Replace("//", "")
$SSN = $SSN.Replace("./", "")
$SSN = $SSN.Replace(".cmd", "")
$SSN = $SSN.Replace(".bat", "")
$SSN = $SSN.Replace(".ps1", "")
$SSN = $SSN.Replace(".psm1", "")
$SSN = $SSN.Replace("/", "-")
$SSN = $SSN.Replace("\", "-")
$SSN = if ($SSN.StartsWith('-')) { $SSN.Substring(1) } else { $SSN }
Set-Content $Output (Get-Content $Output), "`nfn-$SSN";


if ($exe -eq "True") {
    Write-Host "[INFO] Compiling to executable: $exe"
    if (-not (Get-Command Invoke-PS2EXE -ErrorAction SilentlyContinue)) {
        Write-Host "[INFO] PS2EXE not found. Downloading module..."
        try {
            Install-Module -Name PS2EXE -Scope CurrentUser -Force -AllowClobber -ErrorAction Stop
            Import-Module PS2EXE -Force
            Write-Host "[INFO] PS2EXE module installed and imported."
        } catch {
            throw "Failed to install PS2EXE module: `n$_"
        }
    } else {
        Import-Module PS2EXE -Force
    }
    if ($ExeConsole) {
        Invoke-PS2EXE -InputFile $Output -OutputFile $($Output).exe
    } else {
        Invoke-PS2EXE -InputFile $Output -OutputFile $($Output).exe -NoConsole -NoOutput
    }
    Write-Host "[SUCCESS] Executable created: $exe" -ForegroundColor Green
}

Write-Host "[WARNING] Ensure to review the output script for any potential issues." -ForegroundColor Yellow